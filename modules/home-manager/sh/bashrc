# Common Config
set -o ignoreeof            # Prevent <C-D> to close window
stty -ixon                  # Disable <C-S> and <C-Q> to stop shell
shopt -s globstar           # ** support
shopt -s nocaseglob         # Case-insensitive globbing

# Readline
bind 'set completion-ignore-case on'  # Completion case-insensitive
bind 'set completion-map-case on'     # Treat hypen and underscores as equivalent

# Prompt
green="$(tput setaf 2 bold)"
cyan="$(tput setaf 6 bold)"
gray="$(tput setaf 240 bold)"
normal="$(tput sgr0)"
prompt() {
	_exit_code=$?

	# direnv
	[ -n "${DIRENV_FILE//}" ] && printf '%senv|' "$gray"

	printf '%s:' "$green$(hostname)$normal"
	printf '%s' "$cyan$(pwd | sed "s#$HOME#~#")$normal"

	tput sgr0
	[ $_exit_code != 0 ] && tput setaf 1
	printf '$'
	tput sgr0
}
PS1='$(prompt) '
PS2='> '


# Plugins
# Fzf key bindings
bind -x '"\t": fzf_bash_completion'

# Fzf completion
# Hacky way to deal with the bash cleaning the prompt when complete
# Replace the loading msg and fzf prompt with ${PS1@P}
_fzf_bash_completion_loading_msg() { echo "${PS1@P}${READLINE_LINE}" | tail -n1; }
_fzf_bash_completion_selector() {
	FZF_DEFAULT_OPTS="--height ${FZF_TMUX_HEIGHT:-40%} --reverse $FZF_DEFAULT_OPTS $FZF_COMPLETION_OPTS" \
		$(__fzfcmd 2>/dev/null || echo fzf) -1 -0 --prompt "${PS1@P}$line" --nth 2 -d "$_FZF_COMPLETION_SEP" --ansi \
		| tr -d "$_FZF_COMPLETION_SEP"
}

# Tmuxinator-fzf
bind -x '"\C-b": tmuxinator-fzf'

# Auto start tmux
# if command -v tmux &> /dev/null && [ -n "$PS1" ] && [[ ! "$TERM" =~ screen ]] && [[ ! "$TERM" =~ tmux ]] && [ -z "$TMUX" ]; then
#   exec tmuxinator start default
# fi
